LOG PROGETTO:


0 - INSTALLLAZIONE SOFTWARE VARI:

sudo apt install snapd
sudo snap install snapd
[installazione docker e sudo systemctl start docker per farlo partire al boot]
sudo snap install kubectl --classic #installa kubectl


1- INSTALLAZIONE KIND: serve per creare cluster con container docker

curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-arm64
sudo rm /usr/local/bin/kind # per sicurezza
chmod +x ./kind
sudo mv ./kind /usr/local/bin/kind

Per creare/cancellare il cluster Kind:
creaZIONE file yaml kind-config.yaml
sudo kind create cluster --config kind-config.yaml
sudo kind delete cluster #rimuove tutti i nodi del cluster

comandi kind:
sudo kind get nodes
sudo kind get clusters
> sudo kind export kubeconfig --name kind #se kubectl non punta al cluster kind

comandi kubectl:
sudo kubectl config get-contexts: per vedere se punta a kind
sudo kubectl config use-context kind-kind: per usare il giusto contesto
sudo kubectl cluster-info: fa vedere il cluster
sudo kubectl cluster-info --context kind-kind: fa vedere il cluster
sudo kubectl cluster-info dump: dumpa un macello di info
sudo kubectl get nodes: vedi i nodi, se ce li hai. Con kind sono container e non nodi
sudo kubectl get all
Quindi posso usare tutti i comandi di microk8s kubectl senza scrivere microk8s!!!!


2 - CREAZIONE IMMAGINE DOCKER

sudo docker build -t giacomoalfani/asdn_project . #creazione immagine con nginx e index.html
sudo docker push giacomoalfani/asdn_project:latest #push su dockerhub


3 - FILE YAML E DEPLOY

creato file yaml di cluster deploy
> sudo kubectl apply -f cluster_deployment.yaml
sudo kubectl get all #si vedono

In teoria nel cluster composto da container che simulano i nodi, il deploy ha creato pod dentro i container (perchè per lui sono nodi)
Si verifica con sudo kubectl get pods -o wide che mostra se sono in esecuzione e su quale nodo girano.
Per esporre il cluster non serve creare manualmente il SERVICE ma lo fa lui così:

> sudo kubectl expose deployment <DEPLOY NAME> --type=NodePort --port=80

(sudo kubectl get pods -o wide)
sudo kubectl get nodes -o wide #per vedere gli ip dei pod


Quindi per raggiungere il nodo bisogna fare:
curl <ip interno del nodo>:<porta esposta dal service all'esterno>
(curl 172.18.0.3:32662), questo permette di avere quella porta aperta nei nodi/container ma non lo collega con localhost ma non ci 
interessa per ora.


 APPLICAZIONE: 172.18.0.3:31852


Quindi faremo curl 172.18.0.4:31852 per contattare la nostra applicazione
sudo kubectl exec -it clusterdeplo-7c6bcfb8c6-6wcc2 -- /bin/sh #per entrare nel nodo

modificando il file di config si sono aggiunte le configurazioni delle porte esposte.


4 - JENKINS

Jenkins dovrà:
    - collegarsi a github per verificare le nuove push;
    - quando c'è fare dei test sul codice, cioè su index.html, tipo di sintassi;
    - lanciare docker build sul dockerfile;
    - fare push immagine su dockerhub;
    - lanciare cluster_deployment.

creato file Jenkins_deployment.yaml
sudo kubectl apply -f jenkins_deployment.yaml

creato file jenkins_service.yaml
sudo kubectl apply -f jenkins_service.yaml

ha creato un nuovo pod dentro in nodo kind-worker, ecco perchè:
    - Separazione delle Responsabilità: Il nodo master è responsabile della gestione del cluster stesso, 
    incluso il controllo degli stati dei nodi, il monitoraggio e la gestione dei pod. Eseguire Jenkins 
    sul nodo master potrebbe mettere a rischio la stabilità del cluster, soprattutto se Jenkins richiede molte risorse.

    - Scalabilità e Manutenibilità: Separare Jenkins dal nodo master consente di scalare e gestire le risorse in modo 
    più efficiente. I nodi worker possono essere scalati in base alle necessità di carico di lavoro, mentre il master 
    rimane concentrato sulla gestione del cluster.

    - Sicurezza: Limitare i processi in esecuzione sul nodo master può ridurre la superficie di attacco, mantenendo 
    il master dedicato alla gestione del cluster.


JENKINS: 172.18.0.2:30000

sudo kubectl get pods -o wide #per nome pod
sudo kubectl logs <POD NAME> #per trovare la password
password: d33a9def65ab42d2b7eaf7f5b333b2bb

credenziali:
    user: admin
    password: admin
    email: giacomoalfani@gmail.com

inserimento credenziali da manage credentials.
per kubernetes si crea un servizio, un file yaml e si applica:

sudo kubectl create serviceaccount jenkins-sa
sudo kubectl apply -f jenkins_sa_binding.yaml

sudo kubectlget secret -A #per capire quale è il nome del secret
sudo kubectl describe secret <SECRET NAME> -n kube-system #volendo si può togliere il nome del namespace

sudo kubectl create token jenkins-sa #se non funzionano i precedenti


troubleshooting:
sudo kubectl exec -it jenkins-55c5796998-6wfvf -- curl http://localhost:8080 #vedo se funziona jenkins da dentro il container

L'iimagine di jenkins su dockerhub non aveva nulla dentro, quindi si è creato un dockerfile apposito per installarci tutto, 
poi pushato su dockerhub e rideployato col file yaml di deploy di jenkins






5 - OPERATE



6 - GRAFANA